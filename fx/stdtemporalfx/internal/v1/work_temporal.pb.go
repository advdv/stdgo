// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: fx/stdtemporalfx/internal/v1/work.proto
package internalv1

import (
	"context"
	"errors"
	"fmt"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"sync"
	"sync/atomic"
	"time"
)

// TestServiceTaskQueue is the default task-queue for a fx.stdtemporalfx.internal.v1.TestService worker
var TestServiceTaskQueue = "test-v1"

// fx.stdtemporalfx.internal.v1.TestService workflow names
const (
	FooWorkflowName = "fx.stdtemporalfx.internal.v1.TestService.Foo"
)

// fx.stdtemporalfx.internal.v1.TestService activity names
const (
	BarActivityName = "fx.stdtemporalfx.internal.v1.TestService.Bar"
)

// TestServiceClient describes a client for a(n) fx.stdtemporalfx.internal.v1.TestService worker
type TestServiceClient interface {
	// Foo executes a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow and blocks until error or response received
	Foo(ctx context.Context, req *FooInput, opts ...*FooOptions) (*FooOutput, error)

	// FooAsync starts a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow and returns a handle to the workflow run
	FooAsync(ctx context.Context, req *FooInput, opts ...*FooOptions) (FooRun, error)

	// GetFoo retrieves a handle to an existing fx.stdtemporalfx.internal.v1.TestService.Foo workflow execution
	GetFoo(ctx context.Context, workflowID string, runID string) FooRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// testServiceClient implements a temporal client for a fx.stdtemporalfx.internal.v1.TestService service
type testServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewTestServiceClient initializes a new fx.stdtemporalfx.internal.v1.TestService client
func NewTestServiceClient(c client.Client, options ...*testServiceClientOptions) TestServiceClient {
	var cfg *testServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewTestServiceClientOptions()
	}
	return &testServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewTestServiceClientWithOptions initializes a new TestService client with the given options
func NewTestServiceClientWithOptions(c client.Client, opts client.Options, options ...*testServiceClientOptions) (TestServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *testServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewTestServiceClientOptions()
	}
	return &testServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// testServiceClientOptions describes optional runtime configuration for a TestServiceClient
type testServiceClientOptions struct {
	log *slog.Logger
}

// NewTestServiceClientOptions initializes a new testServiceClientOptions value
func NewTestServiceClientOptions() *testServiceClientOptions {
	return &testServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *testServiceClientOptions) WithLogger(l *slog.Logger) *testServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *testServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// fx.stdtemporalfx.internal.v1.TestService.Foo executes a fx.stdtemporalfx.internal.v1.TestService.Foo workflow and blocks until error or response received
func (c *testServiceClient) Foo(ctx context.Context, req *FooInput, options ...*FooOptions) (*FooOutput, error) {
	run, err := c.FooAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// FooAsync starts a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow and returns a handle to the workflow run
func (c *testServiceClient) FooAsync(ctx context.Context, req *FooInput, options ...*FooOptions) (FooRun, error) {
	var o *FooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, FooWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &fooRun{
		client: c,
		run:    run,
	}, nil
}

// GetFoo fetches an existing fx.stdtemporalfx.internal.v1.TestService.Foo execution
func (c *testServiceClient) GetFoo(ctx context.Context, workflowID string, runID string) FooRun {
	return &fooRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *testServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *testServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// FooOptions provides configuration for a fx.stdtemporalfx.internal.v1.TestService.Foo workflow operation
type FooOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewFooOptions initializes a new FooOptions value
func NewFooOptions() *FooOptions {
	return &FooOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *FooOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = TestServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *FooOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *FooOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *FooOptions) WithExecutionTimeout(d time.Duration) *FooOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *FooOptions) WithID(id string) *FooOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *FooOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *FooOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *FooOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *FooOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *FooOptions) WithRunTimeout(d time.Duration) *FooOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *FooOptions) WithSearchAttributes(sa map[string]any) *FooOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *FooOptions) WithTaskTimeout(d time.Duration) *FooOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *FooOptions) WithTaskQueue(tq string) *FooOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *FooOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *FooOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// FooRun describes a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow run
type FooRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*FooOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// fooRun provides an internal implementation of a(n) FooRunRun
type fooRun struct {
	client *testServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *fooRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *fooRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *fooRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *fooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *fooRun) Get(ctx context.Context) (*FooOutput, error) {
	var resp FooOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *fooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// testServiceRegistrationMutex is a mutex for registering fx.stdtemporalfx.internal.v1.TestService workflows
	testServiceRegistrationMutex sync.Mutex
	// FooFunction implements a "fx.stdtemporalfx.internal.v1.TestService.Foo" workflow
	FooFunction func(workflow.Context, *FooInput) (*FooOutput, error)
)

// TestServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// TestServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	TestServiceWorkflowFunctions interface {
		// Foo executes a "fx.stdtemporalfx.internal.v1.TestService.Foo" workflow inline
		Foo(workflow.Context, *FooInput) (*FooOutput, error)
	}
	// testServiceWorkflowFunctions provides an internal TestServiceWorkflowFunctions implementation
	testServiceWorkflowFunctions struct{}
)

func NewTestServiceWorkflowFunctions() TestServiceWorkflowFunctions {
	return &testServiceWorkflowFunctions{}
}

// Foo executes a "fx.stdtemporalfx.internal.v1.TestService.Foo" workflow inline
func (f *testServiceWorkflowFunctions) Foo(ctx workflow.Context, req *FooInput) (*FooOutput, error) {
	if FooFunction == nil {
		return nil, errors.New("Foo requires workflow registration via RegisterTestServiceWorkflows or RegisterFooWorkflow")
	}
	return FooFunction(ctx, req)
}

// TestServiceWorkflows provides methods for initializing new fx.stdtemporalfx.internal.v1.TestService workflow values
type TestServiceWorkflows interface {
	// Foo initializes a new a(n) FooWorkflow implementation
	Foo(ctx workflow.Context, input *FooWorkflowInput) (FooWorkflow, error)
}

// RegisterTestServiceWorkflows registers fx.stdtemporalfx.internal.v1.TestService workflows with the given worker
func RegisterTestServiceWorkflows(r worker.WorkflowRegistry, workflows TestServiceWorkflows) {
	RegisterFooWorkflow(r, workflows.Foo)
}

// RegisterFooWorkflow registers a fx.stdtemporalfx.internal.v1.TestService.Foo workflow with the given worker
func RegisterFooWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *FooWorkflowInput) (FooWorkflow, error)) {
	testServiceRegistrationMutex.Lock()
	defer testServiceRegistrationMutex.Unlock()
	FooFunction = buildFoo(wf)
	r.RegisterWorkflowWithOptions(FooFunction, workflow.RegisterOptions{Name: FooWorkflowName})
}

// buildFoo converts a Foo workflow struct into a valid workflow function
func buildFoo(ctor func(workflow.Context, *FooWorkflowInput) (FooWorkflow, error)) func(workflow.Context, *FooInput) (*FooOutput, error) {
	return func(ctx workflow.Context, req *FooInput) (*FooOutput, error) {
		input := &FooWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// FooWorkflowInput describes the input to a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow constructor
type FooWorkflowInput struct {
	Req *FooInput
}

// FooWorkflow describes a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow implementation
type FooWorkflow interface {
	// Execute defines the entrypoint to a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow
	Execute(ctx workflow.Context) (*FooOutput, error)
}

// FooChild executes a child fx.stdtemporalfx.internal.v1.TestService.Foo workflow and blocks until error or response received
func FooChild(ctx workflow.Context, req *FooInput, options ...*FooChildOptions) (*FooOutput, error) {
	childRun, err := FooChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// FooChildAsync starts a child fx.stdtemporalfx.internal.v1.TestService.Foo workflow and returns a handle to the child workflow run
func FooChildAsync(ctx workflow.Context, req *FooInput, options ...*FooChildOptions) (*FooChildRun, error) {
	var o *FooChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &FooChildRun{Future: workflow.ExecuteChildWorkflow(ctx, FooWorkflowName, req)}, nil
}

// FooChildOptions provides configuration for a child fx.stdtemporalfx.internal.v1.TestService.Foo workflow operation
type FooChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewFooChildOptions initializes a new FooChildOptions value
func NewFooChildOptions() *FooChildOptions {
	return &FooChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *FooChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = TestServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *FooChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *FooChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *FooChildOptions) WithDataConverter(dc converter.DataConverter) *FooChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *FooChildOptions) WithExecutionTimeout(d time.Duration) *FooChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *FooChildOptions) WithID(id string) *FooChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *FooChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *FooChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *FooChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *FooChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *FooChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *FooChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *FooChildOptions) WithRunTimeout(d time.Duration) *FooChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *FooChildOptions) WithSearchAttributes(sa map[string]any) *FooChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *FooChildOptions) WithTaskTimeout(d time.Duration) *FooChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *FooChildOptions) WithTaskQueue(tq string) *FooChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *FooChildOptions) WithWaitForCancellation(wait bool) *FooChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *FooChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *FooChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// FooChildRun describes a child Foo workflow run
type FooChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *FooChildRun) Get(ctx workflow.Context) (*FooOutput, error) {
	var resp FooOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *FooChildRun) Select(sel workflow.Selector, fn func(*FooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *FooChildRun) SelectStart(sel workflow.Selector, fn func(*FooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *FooChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// TestServiceActivities describes available worker activities
type TestServiceActivities interface {
	// fx.stdtemporalfx.internal.v1.TestService.Bar implements a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity definition
	Bar(ctx context.Context, req *BarInput) (*BarOutput, error)
}

// RegisterTestServiceActivities registers activities with a worker
func RegisterTestServiceActivities(r worker.ActivityRegistry, activities TestServiceActivities) {
	RegisterBarActivity(r, activities.Bar)
}

// RegisterBarActivity registers a fx.stdtemporalfx.internal.v1.TestService.Bar activity
func RegisterBarActivity(r worker.ActivityRegistry, fn func(context.Context, *BarInput) (*BarOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: BarActivityName,
	})
}

// BarFuture describes a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity execution
type BarFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *BarFuture) Get(ctx workflow.Context) (*BarOutput, error) {
	var resp BarOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *BarFuture) Select(sel workflow.Selector, fn func(*BarFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Bar executes a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity
func Bar(ctx workflow.Context, req *BarInput, options ...*BarActivityOptions) (*BarOutput, error) {
	return BarAsync(ctx, req, options...).Get(ctx)
}

// BarAsync executes a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity (asynchronously)
func BarAsync(ctx workflow.Context, req *BarInput, options ...*BarActivityOptions) *BarFuture {
	var o *BarActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &BarFuture{Future: errF}
	}
	activity := BarActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &BarFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// BarLocal executes a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity (locally)
func BarLocal(ctx workflow.Context, req *BarInput, options ...*BarLocalActivityOptions) (*BarOutput, error) {
	return BarLocalAsync(ctx, req, options...).Get(ctx)
}

// BarLocalAsync executes a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity (asynchronously, locally)
func BarLocalAsync(ctx workflow.Context, req *BarInput, options ...*BarLocalActivityOptions) *BarFuture {
	var o *BarLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &BarFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = BarActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &BarFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// BarActivityOptions provides configuration for a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity
type BarActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewBarActivityOptions initializes a new BarActivityOptions value
func NewBarActivityOptions() *BarActivityOptions {
	return &BarActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *BarActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = TestServiceTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *BarActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *BarActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *BarActivityOptions) WithDataConverter(dc converter.DataConverter) *BarActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *BarActivityOptions) WithHeartbeatTimeout(d time.Duration) *BarActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BarActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BarActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *BarActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *BarActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *BarActivityOptions) WithScheduleToStartTimeout(d time.Duration) *BarActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *BarActivityOptions) WithStartToCloseTimeout(d time.Duration) *BarActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BarActivityOptions) WithTaskQueue(tq string) *BarActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *BarActivityOptions) WithWaitForCancellation(wait bool) *BarActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// BarLocalActivityOptions provides configuration for a(n) fx.stdtemporalfx.internal.v1.TestService.Bar activity
type BarLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *BarInput) (*BarOutput, error)
}

// NewBarLocalActivityOptions initializes a new BarLocalActivityOptions value
func NewBarLocalActivityOptions() *BarLocalActivityOptions {
	return &BarLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *BarLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom fx.stdtemporalfx.internal.v1.TestService.Bar implementation
func (o *BarLocalActivityOptions) Local(fn func(context.Context, *BarInput) (*BarOutput, error)) *BarLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *BarLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *BarLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *BarLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *BarLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BarLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BarLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *BarLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *BarLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *BarLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *BarLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestTestServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows TestServiceWorkflows
}

var _ TestServiceClient = &TestTestServiceClient{}

// NewTestTestServiceClient initializes a new TestTestServiceClient value
func NewTestTestServiceClient(env *testsuite.TestWorkflowEnvironment, workflows TestServiceWorkflows, activities TestServiceActivities) *TestTestServiceClient {
	if workflows != nil {
		RegisterTestServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterTestServiceActivities(env, activities)
	}
	return &TestTestServiceClient{env, workflows}
}

// Foo executes a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow in the test environment
func (c *TestTestServiceClient) Foo(ctx context.Context, req *FooInput, opts ...*FooOptions) (*FooOutput, error) {
	run, err := c.FooAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// FooAsync executes a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow in the test environment
func (c *TestTestServiceClient) FooAsync(ctx context.Context, req *FooInput, options ...*FooOptions) (FooRun, error) {
	var o *FooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testFooRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetFoo is a noop
func (c *TestTestServiceClient) GetFoo(ctx context.Context, workflowID string, runID string) FooRun {
	return &testFooRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestTestServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestTestServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ FooRun = &testFooRun{}

// testFooRun provides convenience methods for interacting with a(n) fx.stdtemporalfx.internal.v1.TestService.Foo workflow in the test environment
type testFooRun struct {
	client    *TestTestServiceClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *FooInput
	workflows TestServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testFooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test fx.stdtemporalfx.internal.v1.TestService.Foo workflow result
func (r *testFooRun) Get(context.Context) (*FooOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(FooWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result FooOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test fx.stdtemporalfx.internal.v1.TestService.Foo workflow run's workflow ID
func (r *testFooRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testFooRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testFooRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testFooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}
